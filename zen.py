# Итак, мы с вами разобрали словари и то, как они работают, и давайте попробуем решить задачку на их применение.
# В качестве примера попробуем найти три самых часто встречающихся слова в Zen of Python. Как вы уже знаете,
# Zen of Python можно получить, импортировав this, и в нём содержится какой-то набор утверждений, которым должен
# следовать программист, который пишет на Python. Например, красивое лучше чем некрасивое. Давайте создадим нашу
# переменную zen, в которую положим эти замечательные утверждения. Мы должны использовать тройные кавычки, потому что
# здесь есть переносы строк. Скопируем все строки и поместим в zen. Отлично. Теперь нам нужно каким-то образом выяснить,
# какие слова используются чаще всего. Логично нам нужно для начала разбить нашу большую длинную строчку на, собственно,
# эти самые слова. Давайте используем для этого переменную zen_map какой-то dict, где мы будем хранить собственно
# количество слов, которое мы уже нашли, и будем итерироваться с помощью метода split. Метод split разобьёт нашу большую
# строку по пробельным символам. У нас получится какое-то слово при итерации. Теперь, что нам нужно сделать с этим
# словом? Нам нужно, во-первых, его очистить от каких-то точек, от каких-то восклицательных знаков и прочих
# спецсимволов. Давайте назовём переменную cleaned_word и будем очищать наше слово, используя метод строки strip.
# Очистим всё, что мы можем найти. Отлично. Теперь давайте приведём строку к нижнему регистру с помощью метода lower.
# И теперь нам нужно добавить нашу строку в наш zen_map. Если строка уже есть в zen_map'е, мы просто хотим
# инкрементировать counter, который говорит о том, сколько раз мы находили уже это слово. Если строки там нет, то мы
# туда должны её добавить, и давайте именно это и сделаем. Если cleaned_word'а ещё нету в zen_map'е, мы добавим наш
# zen_map в cleaned_word. В качестве значения у нас будет 0, потому что мы это слово ещё не встречали. Если мы его
# встречали или только что добавили, мы инкрементируем это значение. Таким образом, в нашем zen_map'e будет хранится
# отображение из слова в количество раз, в котором мы его встретили. Давайте попробуем вывести наш zen_map. Отлично.
# У нас хранится отображение из строки в количество раз, в котором мы её встретили. Например, beautiful у нас
# встретилось всего один раз, а is встретилось десять раз. Теперь нам нужно каким-то образом выяснить, какие слова
# встречаются чаще всего. Обратите внимание, как ключи, так и значения в словаре не упорядочены, поэтому нам нужно
# сделать так, чтобы они были упорядочены. Для этого можно воспользоваться, например, методом items и, например, в
# zen_items мы можем положить zen_map.items. Это будет уже список таплов. Обратите внимание, у нас в нашем zen_items
# содержится как ключ, так и значение, но уже в виде тапла, и эту вещь мы уже можем сортировать. Как мы будем это
# делать? Если мы попробуем отсортировать zen_items прямо сейчас, то у нас сортировка произойдёт по первому значению,
# по beautiful. Однако, нам нужно сортировать по второму значению наших таплов, по количеству раз, в котором мы
# встречали это слово. Для этого нам поможет замечательный модуль operator и функция sorted. Воспользуемся функцией
# sorted и будем сортировать наши zen_items. Чтобы сортировать по второму значению в нашем тапле, мы можем в качестве
# аргумента key передать туда operator.itemgetter и написать единичку, потому что нас интересует именно первый индекс.
# beautiful — это нулевой индекс, единичка — это первый индекс. Так как нам нужны самые популярные слова, мы используем
# reverse=True. Давайте попробуем вывести word_count_items и возьмём первые три элемента. Отлично, у нас получилось,
# что самые популярные слова, это is, better, than, что мы собственно и ожидали. Однако, как это часто бывает в
# Python'е, есть встроенный модуль, который вам поможет решить эту задачу намного быстрее. Мы можем импортировать из
# модуля collections Counter. В случае, если мы используем Counter, всё, что нам нужно — это очистить наши слова и
# передать эти слова в Counter. Давайте именно это и сделаем. Создадим cleaned_list, в который в цикле будем добавлять
# очищенные слова уже знакомым образом, используя метод split, который разбивает строку по пробельным символам, и будем
# добавлять в cleaned_list с помощью метода append очищенное слово. Очищенное слово будет получено с помощью метода
# strip и приведения к нижнему регистру с помощью метода lower. Итак, всё, что нам осталось сделать, это вызвать counter
# с cleaned_list'ом и обратиться к методу most_common, перадать ему троечку. Давайте попробуем, что у нас получится.
# Отлично, именно то, что мы ожидали, однако, это достигается с помощью трёх строк кода. Часто в Python'е есть
# встроенные методы и модули, которые вам позволяют делать какие-то вещи легко и удобно. Отлично, мы с вами
# познакомились со словарями и решили задачку на их применение.


import this
import operator

zen = """
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
"""

zen_map = dict()

for word in zen.split():
    cleaned_word = word.strip('.,!-').lower()
    if cleaned_word not in zen_map:
        zen_map[cleaned_word] = 0

    zen_map[cleaned_word] += 1

print(zen_map)

zen_items = zen_map.items()
print(zen_items)

word_count_items = sorted(
    zen_items, key=operator.itemgetter(1), reverse=True
)
print(word_count_items[:5])

# Проверка
from collections import Counter

cleaned_list = []
for word in zen.split():
    cleaned_list.append(word.strip('.,-!').lower())

m = Counter(cleaned_list).most_common(5)
print(m)
